// `generate-readme.go` generates `README.md` using the Go template `README.md.tpl`.

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/go-git/go-git"
	"github.com/whilp/git-urls"
	"golang.org/x/mod/modfile"
	"gopkg.in/russross/blackfriday.v2"
)

const (
	goModFile       = "backend/go.mod"
	packageJSONFile = "frontend/package.json"
	templateFile    = "README.md.tpl"
	readmeFile      = "README.md"
	warning         = "<!--\n" +
		"\t!!! DO NOT EDIT THIS FILE. THIS FILE HAS BEEN AUTOMATICALLY GENERATED USING THE COMMAND `make readme`.\n" +
		"\t!!! EDIT " + templateFile + " INSTEAD, THEN RUN `make readme` TO GENERATE THE FILE README.md.\n" +
		"-->\n\n"
)

type dep struct {
	Name    string
	Version string
	URL     string
}

type data struct {
	Deps struct {
		Frontend []dep
		Backend  []dep
	}
	Repo struct {
		URL string
	}
}

func main() {
	var data data

	tpl, err := template.ParseFiles(templateFile)
	if err != nil {
		panic(err)
	}

	repo, err := git.PlainOpen(".")
	if err != nil {
		panic(err)
	}

	config, err := repo.Config()
	if err != nil {
		panic(err)
	}

	for name, remote := range config.Remotes {
		if name == "origin" {
			if len(remote.URLs) == 0 {
				panic("remote.URLs is empty")
			}

			u, err := giturls.Parse(remote.URLs[0])
			if err != nil {
				panic(err)
			}

			data.Repo.URL = fmt.Sprintf("%s/%s", u.Host, strings.TrimSuffix(u.Path, ".git"))
			break
		}
	}

	goModData, err := ioutil.ReadFile(goModFile)
	if err != nil {
		panic(err)
	}

	goMod, err := modfile.Parse(goModFile, goModData, nil)
	if err != nil {
		panic(err)
	}

	for _, r := range goMod.Require {
		url, err := url.Parse("https://" + r.Mod.Path)
		if err != nil {
			panic(err)
		}

		data.Deps.Backend = append(data.Deps.Backend, dep{
			Name:    url.Path[1:],
			Version: r.Mod.Version,
			URL:     "https://" + r.Mod.Path,
		})
	}

	packageJSON, err := ioutil.ReadFile(packageJSONFile)
	if err != nil {
		panic(err)
	}

	var deps struct {
		Dependencies map[string]string
	}

	if err := json.Unmarshal(packageJSON, &deps); err != nil {
		panic(err)
	}

	for name, version := range deps.Dependencies {
		if len(version) > 0 && version[0] == '^' {
			version = version[1:]
		}

		data.Deps.Frontend = append(data.Deps.Frontend, dep{
			Name:    name,
			Version: version,
			URL:     "https://npmjs.com/package/" + name,
		})
	}

	sort.Slice(data.Deps.Frontend, func(i, j int) bool {
		return data.Deps.Frontend[i].Name < data.Deps.Frontend[j].Name
	})

	sort.Slice(data.Deps.Backend, func(i, j int) bool {
		return data.Deps.Backend[i].Name < data.Deps.Backend[j].Name
	})

	var readme bytes.Buffer

	if _, err := readme.WriteString(warning); err != nil {
		panic(err)
	}

	if err = tpl.Execute(&readme, data); err != nil {
		panic(err)
	}

	md := blackfriday.New()
	ast := md.Parse(readme.Bytes())
	toc := "# Table of contents\n"

	ast.Walk(func(node *blackfriday.Node, entering bool) blackfriday.WalkStatus {
		if entering && node.Type == blackfriday.Heading && node.HeadingData.Level > 1 {
			anchor := strings.Map(func(r rune) rune {
				if r == ' ' {
					return '-'
				}

				return r
			}, strings.ToLower(string(node.FirstChild.Literal)))

			toc += fmt.Sprintf("\n%s* [%s](#%s)", strings.Repeat("  ", node.HeadingData.Level-2), node.FirstChild.Literal, anchor)
		}

		return blackfriday.GoToNext
	})

	f, err := os.Create(readmeFile)
	if err != nil {
		panic(err)
	}

	defer f.Close()

	if _, err := f.Write(bytes.Replace(readme.Bytes(), []byte("__TOC__"), []byte(toc), 1)); err != nil {
		panic(err)
	}
}
